\chapter{Run-time statistics}\label{sec:runtimestats}
This experiment will determine how the processing time is divided between tasks using the FreeRTOS API call \texttt{vTaskGetRunTimeStats}. It is important to know to confirm each task is run by the scheduler. The report gives a hint as to whether the system runs efficiently or not.

Run-time statistics generation is implemented in FreeRTOS by using a separate timer, which increases a counter-variable. When the scheduler switches to any given task, the counter-variable is read and saved. When a new context switch occurs, the counter-variable is read again. The difference of the counter value between the two context switches must then be the total run-time of that particular task. The run-time for each task that the kernel maintains is accumulated and printed upon making a call to \texttt{vTaskGetRunTimeStats}.


\section{Procedure}
The system, in its final implementation, is made to run in auto mode. In auto mode the pan-tilt system will run a demo, moving the frame between two set points. After the demo has run for around 4-5 minutes, the system is prompted to print a run-time statistics report on a console, through the UART.

There are no tasks, which run less often than every half a second or so, so generating statistic across a longer time-span would be pointless.

The timer which is used by FreeRTOS to generate run-time statistics is set to run with a frequency that 40 times higher than the SysTick timer to obtain a good resolution of the measurements.


\section{Results}
Table \ref{tab:runtimestats} shows the run-time statistics report generated by FreeRTOS. From that, we find the following.

\begin{table}[htb]
	\centering
	\begin{tabular}{lrr}
	Task name & Absolute time $\left[ \dfrac{1}{32 \cdot 10^3} \, s \right]$ & Relative time \\
	\midrule
  \texttt{Dreh}	&	\texttt{30088}	&	\texttt{<1\%}\\
  \texttt{LCD}	&	\texttt{234389}	&	\texttt{2\%}\\
  \texttt{UART\_PROT}	&	\texttt{1786}	&	\texttt{<1\%}\\
  \texttt{IDLE}	&	\texttt{7650336}	&	\texttt{77\%}\\
  \texttt{PAR\_UPDATE}&		\texttt{508781}	&	\texttt{5\%}\\
  \texttt{Numpad}	&	\texttt{4941}	&	\texttt{<1\%}\\
  \texttt{Menu}	&	\texttt{34946}	&	\texttt{<1\%}\\
  \texttt{STATUS\_LED}	&	\texttt{395}	&	\texttt{<1\%}\\
  \texttt{Blink}	&	\texttt{771}	&	\texttt{<1\%}\\
  \texttt{Control}	&	\texttt{153066}	&	\texttt{1\%}\\
  \texttt{UART\_TX}	&	\texttt{319}	&	\texttt{<1\%}\\
  \texttt{SPI\_TX}	&	\texttt{467471}	&	\texttt{4\%}\\
  \texttt{SPI\_RX}	&	\texttt{746680}	&	\texttt{7\%}\\
  \texttt{UART\_-\_SPI}	&	\texttt{3}	&	\texttt{<1\%}
	\end{tabular}
	\caption{Generated report of run-time statistics during auto mode.}
	\label{tab:runtimestats}
\end{table}

All tasks that were supposed to run, are running, and none of the tasks seems to be claiming more time than the should. The \texttt{IDLE} task runs 77\% of the time, so it can safely be said, that it is not starved of processor time. The parameter updater task and SPI transmitter and receiver tasks run more than most other. That is not surprising, as the parameter updater task runs quite often and uses the SPI connection.